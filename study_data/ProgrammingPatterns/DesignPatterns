# 编程模式

## 来自你的消息:
编程模式是什么


## 来自 ChatGPT 的消息:
编程模式（Programming Patterns）是一种在软件开发中用于解决特定问题的通用、可重用的解决方案。它们不是针对特定编程语言的解决方案，而是一种跨语言的概念，可以帮助开发人员更有效地构建软件系统。

编程模式可以分为以下几类：

1. 设计模式（Design Patterns）：设计模式是针对面向对象编程的常见问题提出的解决方案。它们可以帮助开发人员编写可复用、可维护、灵活的代码。常见的设计模式包括单例模式、工厂模式、观察者模式等。

2. 架构模式（Architectural Patterns）：架构模式是关于如何组织软件系统的高层次解决方案。它们可以帮助开发人员构建可扩展、可维护的系统。常见的架构模式包括MVC（模型-视图-控制器）、微服务架构、事件驱动架构等。

3. 算法模式（Algorithm Patterns）：算法模式是针对特定问题提出的通用算法解决方案。它们可以帮助开发人员解决复杂问题，提高代码性能。常见的算法模式包括分治法、动态规划、贪心算法等。

4. 代码模式（Code Patterns）：代码模式是关于如何编写可读、可维护的代码的最佳实践。它们可以帮助开发人员提高代码质量，减少错误。常见的代码模式包括DRY（Don't Repeat Yourself）、KISS（Keep It Simple, Stupid）、YAGNI（You Aren't Gonna Need It）等。

通过学习和应用这些编程模式，开发人员可以提高软件开发效率，编写出更高质量的代码。

## 来自你的消息:
详细讲讲设计模式


## 来自 ChatGPT 的消息:
设计模式是面向对象编程中的一种可复用的解决方案，用于解决在软件设计中经常出现的问题。设计模式可以帮助开发人员编写可复用、可维护和灵活的代码。设计模式通常分为三类：创建型、结构型和行为型。

1. 创建型模式（Creational Patterns）：这类模式关注对象的创建过程。它们提供了创建对象的方法，同时隐藏了对象创建的具体细节。常见的创建型模式有：

   - 单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。
   - 工厂方法模式（Factory Method）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。
   - 抽象工厂模式（Abstract Factory）：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。
   - 建造者模式（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
   - 原型模式（Prototype）：通过复制现有的实例来创建新的实例。

2. 结构型模式（Structural Patterns）：这类模式关注对象和类的组织和组合。它们帮助开发人员构建更大的结构，同时保持代码的灵活性和可维护性。常见的结构型模式有：

   - 适配器模式（Adapter）：将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以一起工作。
   - 桥接模式（Bridge）：将抽象部分与实现部分分离，使它们可以独立地变化。
   - 组合模式（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户可以一致性地使用组合结构和单个对象。
   - 装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责，而不影响其他对象。
   - 外观模式（Facade）：为子系统中的一组接口提供一个统一的接口，以简化客户端的使用。
   - 享元模式（Flyweight）：通过共享技术有效地支持大量细粒度的对象。
   - 代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问。

3. 行为型模式（Behavioral Patterns）：这类模式关注对象之间的通信和协作。它们提供了对象间通信的方法，使得对象能够更好地协同工作。常见的行为型模式有：

   - 责任链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
   - 命令模式（Command）：将一个请求封装为一个对象，从而使客户端可以用不同的请求对对象进行参数化。
   - 解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，使用该表示来解释语言中的句子。
   - 迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
   - 中介者模式（Mediator）：定义一个对象，封装一组对象如何交互的细节，从而使这些对象松散地耦合。
   - 备忘录模式（Memento）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后恢复对象。
   - 观察者模式（Observer）：当一个对象的状态发生改变时，它的所有依赖对象都得到通知并自动更新。
   - 状态模式（State）：允许一个对象在其内部状态改变时改变它的行为。
   - 策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换。
   - 模板方法模式（Template Method）：定义一个操作中的算法的骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
   - 访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

了解这些设计模式，并根据实际需求选择合适的模式来解决问题，可以帮助开发人员编写更高质量、更易于维护的代码。

## 来自你的消息:
讲讲单例模式，并举例


## 来自 ChatGPT 的消息:
单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目标是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式常用于需要频繁创建和销毁的对象，以及创建对象需要消耗大量资源并且经常使用的情况。

单例模式的实现通常涉及以下步骤：

1. 将类的构造函数设为私有，防止外部代码创建该类的实例。
2. 创建一个私有静态成员变量，用来保存单例实例。
3. 提供一个公有静态方法（通常命名为 `getInstance` 或 `getSingleton`），用于获取单例实例。

以下是一个简单的Java语言的单例模式实现示例：

```java
public class Singleton {
    // 在静态初始化器中创建单例实例，这段代码保证了线程安全
    private static Singleton uniqueInstance = new Singleton();

    // 将构造函数设为私有，只有Singleton类自己能够实例化
    private Singleton() {}

    // 提供一个全局的静态方法
    public static Singleton getInstance() {
        return uniqueInstance;
    }

    // 添加其他的用于测试的方法
    public void singletonOperation() {
        // 功能处理
    }
}
```

在这个示例中，`Singleton` 类只有一个实例 `uniqueInstance`，并且这个实例在静态初始化器中创建，保证了线程安全。当我们需要使用这个单例实例时，可以通过 `Singleton.getInstance()` 方法获取。

需要注意的是，单例模式虽然简单，但不适用于所有情况。当对象需要持有状态，或者你需要控制对象创建的数量，或者每个用户需要一个单独的数据库连接等情况时，就不应该使用单例模式。

## 来自你的消息:
用c++代码举例，以后都是


## 来自 ChatGPT 的消息:
以下是一个简单的C++语言的单例模式实现示例：

```cpp
#include <iostream>

class Singleton {
public:
    // 获取单例实例的静态方法
    static Singleton& getInstance() {
        static Singleton instance; // 静态局部变量，只会被创建一次
        return instance;
    }

    // 禁止拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    // 添加其他的用于测试的方法
    void singletonOperation() {
        // 功能处理
        std::cout << "Singleton operation executed." << std::endl;
    }

private:
    // 将构造函数和析构函数设为私有
    Singleton() {}
    ~Singleton() {}
};

int main() {
    // 获取单例实例并调用其方法
    Singleton::getInstance().singletonOperation();
    return 0;
}
```

在这个示例中，我们使用C++11的特性实现了单例模式。`Singleton` 类的构造函数和析构函数都是私有的，防止外部代码创建和销毁实例。我们通过 `getInstance` 静态方法获取单例实例，这个方法内部使用了一个静态局部变量 `instance`，它只会被创建一次，从而保证了单例的唯一性。此外，我们还禁止了拷贝构造和赋值操作。

需要注意的是，单例模式虽然简单，但不适用于所有情况。当对象需要持有状态，或者你需要控制对象创建的数量，或者每个用户需要一个单独的数据库连接等情况时，就不应该使用单例模式。

## 来自你的消息:
这个全局访问点就是用getInstance方法获取的吧


## 来自 ChatGPT 的消息:
是的，全局访问点指的就是通过 `getInstance` 方法（或者其他类似名称的方法）获取单例实例的过程。这个方法允许你在代码的任何地方访问这个唯一的实例，而不需要显式地传递实例引用。这样可以确保整个应用程序中只存在一个实例，并且可以在全局范围内方便地访问它。

以C++示例为例，你可以通过以下方式获取单例实例并调用其方法：

```cpp
Singleton::getInstance().singletonOperation();
```

这里，`Singleton::getInstance()` 是全局访问点，它返回一个对唯一 `Singleton` 实例的引用，然后我们可以在这个实例上调用 `singletonOperation()` 方法。同样，在Java示例中，你可以通过 `Singleton.getInstance()` 获取单例实例。

## 来自你的消息:
工厂方法模式（Factory Method）详细讲解，并举个例子

## 来自 ChatGPT 的消息:
工厂方法模式（Factory Method）是一种创建型设计模式，它提供了一种将对象的创建与使用分离的方法。工厂方法模式通过定义一个接口或抽象类来声明创建对象的方法，然后让子类决定实例化哪一个类。这样，当需要创建新的对象时，只需修改工厂方法的子类，而无需修改客户端代码。

工厂方法模式包含以下几个组成部分：

1. Creator（创建者）：这是一个接口或抽象类，它定义了用于创建对象的工厂方法。这个方法通常返回一个抽象类型的实例。
2. ConcreteCreator（具体创建者）：这是实现了Creator接口或继承了Creator抽象类的具体类。它负责创建具体的产品实例。
3. Product（产品）：这是一个接口或抽象类，定义了产品的公共接口。
4. ConcreteProduct（具体产品）：这是实现了Product接口或继承了Product抽象类的具体类。它是工厂方法模式所创建的对象。

以下是一个简单的C++例子，演示了如何使用工厂方法模式创建不同类型的动物：

```cpp
#include <iostream>
#include <memory>

// Product（产品）
class Animal {
public:
    virtual ~Animal() {}
    virtual void speak() = 0;
};

// ConcreteProduct（具体产品）
class Dog : public Animal {
public:
    void speak() override {
        std::cout << "Woof!" << std::endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        std::cout << "Meow!" << std::endl;
    }
};

// Creator（创建者）
class AnimalFactory {
public:
    virtual ~AnimalFactory() {}
    virtual std::unique_ptr<Animal> createAnimal() = 0;
};

// ConcreteCreator（具体创建者）
class DogFactory : public AnimalFactory {
public:
    std::unique_ptr<Animal> createAnimal() override {
        return std::make_unique<Dog>();
    }
};

class CatFactory : public AnimalFactory {
public:
    std::unique_ptr<Animal> createAnimal() override {
        return std::make_unique<Cat>();
    }
};

int main() {
    std::unique_ptr<AnimalFactory> dogFactory = std::make_unique<DogFactory>();
    std::unique_ptr<Animal> dog = dogFactory->createAnimal();
    dog->speak();

    std::unique_ptr<AnimalFactory> catFactory = std::make_unique<CatFactory>();
    std::unique_ptr<Animal> cat = catFactory->createAnimal();
    cat->speak();

    return 0;
}
```

在这个例子中，`Animal` 是产品接口，`Dog` 和 `Cat` 是具体产品。`AnimalFactory` 是创建者接口，而 `DogFactory` 和 `CatFactory` 是具体创建者。客户端代码通过调用具体创建者的 `createAnimal` 方法来创建不同类型的动物。这样，当需要添加新的动物类型时，只需创建一个新的具体创建者类，而无需修改客户端代码。

## 来自你的消息:
这个工厂模式是对应c++多态的特性吗


## 来自 ChatGPT 的消息:
是的，工厂方法模式是一种利用C++（以及其他面向对象编程语言）的多态特性来实现的设计模式。多态允许我们将子类对象当作父类对象来处理，这使得我们可以在运行时动态地改变对象的具体类型。

在工厂方法模式中，Creator（创建者）接口或抽象类定义了一个返回Product（产品）类型的工厂方法，而ConcreteCreator（具体创建者）类则实现了这个方法，返回ConcreteProduct（具体产品）类型的实例。由于ConcreteProduct类型是Product类型的子类，因此我们可以将ConcreteProduct类型的实例当作Product类型的实例来处理，这就是多态的体现。

多态性使得我们可以在运行时根据需要创建不同的ConcreteProduct类型的实例，而无需在编译时确定具体的类型。这就是工厂方法模式能够提供灵活性和可扩展性的原因。

## 来自你的消息:
讲讲抽象工厂模式（Abstract Factory），举例


## 来自 ChatGPT 的消息:
抽象工厂模式（Abstract Factory）是一种创建型设计模式，它提供了一种方式来封装一组具有共同主题的工厂方法，而无需指定它们的具体类。抽象工厂模式允许客户端在运行时切换不同的产品族，同时确保客户端代码与具体产品类解耦。

抽象工厂模式包含以下几个组成部分：

1. AbstractFactory（抽象工厂）：这是一个接口或抽象类，它定义了用于创建一组相关或依赖对象的接口，但不指定具体类。
2. ConcreteFactory（具体工厂）：这是实现了AbstractFactory接口或继承了AbstractFactory抽象类的具体类。它负责创建具体产品族的实例。
3. AbstractProduct（抽象产品）：这是一个接口或抽象类，定义了产品的公共接口。
4. ConcreteProduct（具体产品）：这是实现了AbstractProduct接口或继承了AbstractProduct抽象类的具体类。它是抽象工厂模式所创建的对象。

以下是一个使用Java实现的抽象工厂模式的例子，演示了如何创建不同类型的UI组件：

```java
// AbstractProductA（抽象产品A）
interface Button {
    void render();
}

// ConcreteProductA1（具体产品A1）
class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering a Windows button.");
    }
}

// ConcreteProductA2（具体产品A2）
class MacOSButton implements Button {
    public void render() {
        System.out.println("Rendering a macOS button.");
    }
}

// AbstractProductB（抽象产品B）
interface Checkbox {
    void render();
}

// ConcreteProductB1（具体产品B1）
class WindowsCheckbox implements Checkbox {
    public void render() {
        System.out.println("Rendering a Windows checkbox.");
    }
}

// ConcreteProductB2（具体产品B2）
class MacOSCheckbox implements Checkbox {
    public void render() {
        System.out.println("Rendering a macOS checkbox.");
    }
}

// AbstractFactory（抽象工厂）
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// ConcreteFactory1（具体工厂1）
class WindowsGUIFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

// ConcreteFactory2（具体工厂2）
class MacOSGUIFactory implements GUIFactory {
    public Button createButton() {
        return new MacOSButton();
    }

    public Checkbox createCheckbox() {
        return new MacOSCheckbox();
    }
}

public class Main {
    public static void main(String[] args) {
        GUIFactory factory;

        String osName = System.getProperty("os.name").toLowerCase();
        if (osName.contains("windows")) {
            factory = new WindowsGUIFactory();
        } else {
            factory = new MacOSGUIFactory();
        }

        Button button = factory.createButton();
        Checkbox checkbox = factory.createCheckbox();

        button.render();
        checkbox.render();
    }
}
```

在这个例子中，我们有两个抽象产品：`Button` 和 `Checkbox`，以及它们的具体实现类。`GUIFactory` 是抽象工厂接口，它定义了创建按钮和复选框的方法。`WindowsGUIFactory` 和 `MacOSGUIFactory` 是具体工厂类，它们分别实现了创建不同操作系统下的UI组件的方法。

客户端代码通过调用具体工厂的方法来创建和使用不同类型的UI组件。这样，当需要添加新的UI组件或新的操作系统支持时，只需创建一个新的具体工厂类，而无需修改客户端代码。

## 来自你的消息:
以后举例用c++


## 来自 ChatGPT 的消息:
当然可以。以下是一个使用C++实现的抽象工厂模式的例子，演示了如何创建不同类型的UI组件：

```cpp
#include <iostream>
#include <memory>

// AbstractProductA（抽象产品A）
class Button {
public:
    virtual void render() = 0;
};

// ConcreteProductA1（具体产品A1）
class WindowsButton : public Button {
public:
    void render() override {
        std::cout << "Rendering a Windows button." << std::endl;
    }
};

// ConcreteProductA2（具体产品A2）
class MacOSButton : public Button {
public:
    void render() override {
        std::cout << "Rendering a macOS button." << std::endl;
    }
};

// AbstractProductB（抽象产品B）
class Checkbox {
public:
    virtual void render() = 0;
};

// ConcreteProductB1（具体产品B1）
class WindowsCheckbox : public Checkbox {
public:
    void render() override {
        std::cout << "Rendering a Windows checkbox." << std::endl;
    }
};

// ConcreteProductB2（具体产品B2）
class MacOSCheckbox : public Checkbox {
public:
    void render() override {
        std::cout << "Rendering a macOS checkbox." << std::endl;
    }
};

// AbstractFactory（抽象工厂）
class GUIFactory {
public:
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<Checkbox> createCheckbox() = 0;
};

// ConcreteFactory1（具体工厂1）
class WindowsGUIFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WindowsButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<WindowsCheckbox>();
    }
};

// ConcreteFactory2（具体工厂2）
class MacOSGUIFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacOSButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<MacOSCheckbox>();
    }
};

int main() {
    std::unique_ptr<GUIFactory> factory;

    std::string osName = "macos"; // 这里简化了操作系统检测的过程

    if (osName == "windows") {
        factory = std::make_unique<WindowsGUIFactory>();
    } else if (osName == "macos") {
        factory = std::make_unique<MacOSGUIFactory>();
    } else {
        std::cout << "Error: unknown operating system." << std::endl;
        return 1;
    }

    auto button = factory->createButton();
    auto checkbox = factory->createCheckbox();

    button->render();
    checkbox->render();

    return 0;
}
```

在这个例子中，我们定义了两个抽象产品（Button 和 Checkbox）以及它们的具体实现（WindowsButton、MacOSButton、WindowsCheckbox 和 MacOSCheckbox）。我们还定义了一个抽象工厂（GUIFactory）和两个具体工厂（WindowsGUIFactory 和 MacOSGUIFactory），这些工厂分别创建各自操作系统的UI组件。

在main函数中，我们根据操作系统名称创建了一个具体的工厂实例，然后使用该工厂创建了Button和Checkbox实例。这个例子演示了如何使用抽象工厂模式来创建一组具有共同主题的对象，同时保持客户端代码与具体产品类解耦。

## 来自你的消息:
抽象工厂模式和工厂模式有什么区别


## 来自 ChatGPT 的消息:
抽象工厂模式和工厂方法模式都属于创建型设计模式，它们用于创建对象，但它们的用途和实现方式有所不同。以下是它们之间的主要区别：

1. 目的：
   工厂方法模式（Factory Method）主要用于创建一种类型的对象，而抽象工厂模式（Abstract Factory）用于创建一组相关或相互依赖的对象。

2. 结构：
   在工厂方法模式中，我们通常有一个抽象工厂类（或接口）和多个具体工厂类。抽象工厂类定义了一个用于创建对象的接口，而具体工厂类负责创建具体的产品实例。
   在抽象工厂模式中，我们有一个抽象工厂类（或接口）和多个具体工厂类。抽象工厂类定义了一组用于创建相关或相互依赖对象的接口，而具体工厂类负责创建具体的产品族实例。

3. 适用场景：
   工厂方法模式适用于以下情况：
   - 当一个类无法预知它需要创建哪种类的对象时。
   - 当一个类希望由其子类来指定创建的对象时。
   - 当将创建对象的任务委托给多个帮助类中的某一个，并希望将哪一个帮助类实际创建对象的细节从客户端代码中隐藏时。
   
   抽象工厂模式适用于以下情况：
   - 当需要创建一组相关或相互依赖的对象时，而不需要指定它们的具体类。
   - 当希望将一组对象的创建与使用相分离时。
   - 当希望在运行时切换不同的产品族，而不需要修改客户端代码时。

总结一下，工厂方法模式主要关注创建单一类型的对象，而抽象工厂模式关注创建一组具有共同主题的对象。工厂方法模式侧重于将对象创建的过程延迟到子类，而抽象工厂模式侧重于在运行时切换不同的产品族。

## 来自你的消息:
从某种意义上来说，抽象工厂方法模式是包括了工厂方法模式的，也就是说工厂方法模式是抽象工厂方法模式的子集

## 来自 ChatGPT 的消息:
从某种程度上说，这种说法是正确的。工厂方法模式可以被认为是抽象工厂模式的一个特殊情况，即只有一个产品类型时的抽象工厂模式。在这种情况下，抽象工厂模式和工厂方法模式的结构和行为变得非常相似。

然而，它们在目的、适用场景和实现上仍然有一些区别。正如我们之前讨论的那样，工厂方法模式主要用于创建一种类型的对象，而抽象工厂模式用于创建一组相关或相互依赖的对象。因此，在实际应用中，根据问题的具体需求选择合适的设计模式是非常重要的。

总之，尽管工厂方法模式可以被认为是抽象工厂模式的一个子集（特殊情况），但它们在实际应用中仍然有一些重要的区别。了解这些区别并根据具体需求选择合适的设计模式是关键。

## 来自你的消息:
建造者模式（Builder），详细讲讲，并用c++代码举例

## 来自 ChatGPT 的消息:
建造者模式（Builder）是一种创建型设计模式，它用于将一个复杂对象的构建过程与其表示分离。这样，同一个构建过程可以创建不同的表示。建造者模式主要用于创建具有多个组成部分的复杂对象，特别是当对象的创建过程需要遵循特定的步骤时。

建造者模式通常包括以下几个角色：
1. 产品（Product）：表示需要构建的复杂对象。
2. 抽象建造者（Builder）：定义用于创建产品对象的接口，包括创建和组装各个部分的方法。
3. 具体建造者（Concrete Builder）：实现抽象建造者接口，负责创建和组装产品的各个部分。
4. 指挥者（Director）：负责调用建造者的方法来组装产品，指挥者通常不需要知道产品的具体实现细节。

以下是一个使用C++实现的简单建造者模式示例：

```cpp
#include <iostream>
#include <string>

// 产品类
class Product {
public:
    void setPartA(const std::string& partA) { partA_ = partA; }
    void setPartB(const std::string& partB) { partB_ = partB; }
    void show() {
        std::cout << "Product parts: " << partA_ << ", " << partB_ << std::endl;
    }

private:
    std::string partA_;
    std::string partB_;
};

// 抽象建造者类
class Builder {
public:
    virtual ~Builder() = default;
    virtual void buildPartA() = 0;
    virtual void buildPartB() = 0;
    virtual Product getProduct() = 0;
};

// 具体建造者类
class ConcreteBuilder : public Builder {
public:
    void buildPartA() override { product_.setPartA("PartA1"); }
    void buildPartB() override { product_.setPartB("PartB1"); }
    Product getProduct() override { return product_; }

private:
    Product product_;
};

// 指挥者类
class Director {
public:
    explicit Director(Builder* builder) : builder_(builder) {}
    void construct() {
        builder_->buildPartA();
        builder_->buildPartB();
    }

private:
    Builder* builder_;
};

int main() {
    ConcreteBuilder builder;
    Director director(&builder);
    director.construct();
    Product product = builder.getProduct();
    product.show();

    return 0;
}
```

在这个示例中，我们有一个`Product`类，它表示需要构建的复杂对象。`Builder`类是抽象建造者，它定义了创建产品对象的接口。`ConcreteBuilder`类实现了`Builder`接口，负责创建和组装产品的各个部分。`Director`类负责调用建造者的方法来组装产品。

在`main`函数中，我们创建了一个`ConcreteBuilder`实例和一个`Director`实例。然后，我们使用指挥者来组装产品，并通过建造者获取最终的产品对象。最后，我们展示产品的各个部分。
